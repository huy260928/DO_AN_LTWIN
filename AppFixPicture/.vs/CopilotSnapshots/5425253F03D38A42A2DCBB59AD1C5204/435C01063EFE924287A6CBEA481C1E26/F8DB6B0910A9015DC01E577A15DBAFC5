using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Reflection;
using System.Windows.Forms;

namespace AppFixPicture
{
    // Partial so Designer owns control fields and InitializeComponent
    public partial class AnnotationForm : Form
    {
        private enum Tool { None, Select, Pencil, Rectangle, Circle, Arrow, Text }

        // state
        private Tool currentTool = Tool.Pencil;
        private Color currentColor = Color.Red;
        private float zoom = 1.0f;
        private int currentFontSize = 12;
        // Keep the selected Font (not just size) so text uses chosen family/style/size
        private Font currentFont = new Font(FontFamily.GenericSansSerif, 12f);
        private Pen currentPen => new Pen(currentColor, 2);

        private Bitmap baseBitmap; // canonical image where drawing is applied
        private Bitmap workingBitmap; // scaled image for display
        private Bitmap originalBitmap; // original loaded image for full clear/restore
        private Bitmap displayBitmap; // bitmap actually shown in PictureBox (may be scaled to fit)

        // NEW: preview container so image cannot overlap toolstrip/status
        private Panel previewPanel;

        // Store annotations as objects so we can select/move text
        private class TextAnnotation
        {
            public string Text;
            public Font Font;
            public Color Color;
            // Location in image coordinates (pixels of the bitmap)
            public Point Location;
        }

        // Editor state for undo/redo
        private class EditorState
        {
            public Bitmap Bitmap; // stores a copy of baseBitmap
            public List<TextAnnotation> Annotations;
            public EditorState(Bitmap bmp, List<TextAnnotation> ann)
            {
                Bitmap = bmp;
                Annotations = ann;
            }
        }

        private Stack<EditorState> undoStack = new Stack<EditorState>();
        private Stack<EditorState> redoStack = new Stack<EditorState>();
        private List<TextAnnotation> textAnnotations = new List<TextAnnotation>();

        private TextAnnotation selectedText = null;
        private bool isDraggingText = false;
        // drag offset in control coordinates
        private Point dragOffset;

        private bool isDrawing = false;
        // lastPoint stored in image coordinates
        private Point lastPoint;

        // Expose edited image to caller when user applies annotations
        public Bitmap EditedImage { get; private set; }

        public AnnotationForm()
        {
            Text = "Annotation";
            ClientSize = new Size(1000, 700);

            // Designer-created UI
            InitializeComponent();

            // Create previewPanel and move pictureBoxCanvas into it so we can control layout
            try
            {
                previewPanel = new Panel();
                previewPanel.Location = new Point(0, toolStripTop.Bottom);
                previewPanel.Size = new Size(this.ClientSize.Width, this.ClientSize.Height - toolStripTop.Height - statusStripBottom.Height);
                previewPanel.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
                previewPanel.BorderStyle = BorderStyle.None;
                previewPanel.AutoScroll = true;

                // Remove pictureBoxCanvas from form controls and add to previewPanel
                this.Controls.Remove(pictureBoxCanvas);
                pictureBoxCanvas.Parent = previewPanel;
                pictureBoxCanvas.Location = new Point(0, 0);
                pictureBoxCanvas.Anchor = AnchorStyles.Top | AnchorStyles.Left;
                previewPanel.Controls.Add(pictureBoxCanvas);

                // Add previewPanel to form just below toolStripTop
                this.Controls.Add(previewPanel);
                // Ensure toolstrip and statusstrip remain visible
                toolStripTop.BringToFront();
                statusStripBottom.BringToFront();

                // handle panel resize to relayout image
                previewPanel.Resize += (s, e) => FitPictureBoxToImage();
            }
            catch { }

            // enable double buffering to reduce flicker
            try
            {
                this.DoubleBuffered = true;
                // enable protected DoubleBuffered on PictureBox via reflection
                var prop = typeof(Control).GetProperty("DoubleBuffered", BindingFlags.Instance | BindingFlags.NonPublic);
                prop?.SetValue(pictureBoxCanvas, true, null);
            }
            catch { }

            // keep pictureBox centered when form resizes
            this.Resize += (s, e) => FitPictureBoxToImage();

            WireEvents();
            UpdateStatus();

            // initialize font size combo text if present
            try { cbFontSize.Text = currentFontSize.ToString(); } catch { }
        }

        // New constructor to accept initial image from Form1
        public AnnotationForm(Image initialImage) : this()
        {
            if (initialImage != null)
            {
                originalBitmap?.Dispose();
                baseBitmap?.Dispose();

                originalBitmap = new Bitmap(initialImage);
                baseBitmap = new Bitmap(originalBitmap);
                workingBitmap?.Dispose();
                workingBitmap = GetScaledBitmap(baseBitmap, zoom);
                // set pictureBox to image size and enable scrolling
                try
                {
                    pictureBoxCanvas.SizeMode = PictureBoxSizeMode.Normal; // we'll manage scaling and scrolling
                    // prepare displayBitmap via FitPictureBoxToImage
                    FitPictureBoxToImage();
                    if (previewPanel != null) previewPanel.AutoScroll = true;
                }
                catch { }
                zoom = 1.0f;
                UpdateStatus();
            }
        }

        private void WireEvents()
        {
            // wire events for controls created in designer
            btnOpen.Click += BtnOpen_Click;
            btnColor.Click += BtnColor_Click;
            btnFont.Click += BtnFont_Click;
            cbFontSize.SelectedIndexChanged += (s, e) => {
                if (int.TryParse(cbFontSize.Text, out int v))
                {
                    currentFontSize = v;
                    // update currentFont while preserving family and style
                    try
                    {
                        var family = currentFont?.FontFamily ?? FontFamily.GenericSansSerif;
                        var style = currentFont?.Style ?? FontStyle.Regular;
                        // dispose old font and create a new one with new size
                        currentFont?.Dispose();
                        currentFont = new Font(family, currentFontSize, style);

                        // if a text is selected, update its font as well
                        if (selectedText != null)
                        {
                            selectedText.Font?.Dispose();
                            selectedText.Font = new Font(family, currentFontSize, style);
                        }
                    }
                    catch
                    {
                        // ignore invalid sizes
                    }
                }
            };

            btnSelect.Click += (s, e) => SetTool(Tool.Select);
            btnPencil.Click += (s, e) => SetTool(Tool.Pencil);
            btnRect.Click += (s, e) => SetTool(Tool.Rectangle);
            btnCircle.Click += (s, e) => SetTool(Tool.Circle);
            btnArrow.Click += (s, e) => SetTool(Tool.Arrow);
            btnText.Click += (s, e) => SetTool(Tool.Text);

            btnUndo.Click += BtnUndo_Click;
            btnRedo.Click += BtnRedo_Click;
            btnSave.Click += BtnSave_Click;
            btnClear.Click += BtnClear_Click;
            btnZoomIn.Click += (s, e) => { zoom += 0.1f; ApplyZoom(); };
            btnZoomOut.Click += (s, e) => { zoom = Math.Max(0.1f, zoom - 0.1f); ApplyZoom(); };
            btnApply.Click += (s, e) => ApplyAnnotationsAndClose();

            pictureBoxCanvas.MouseDown += PictureBoxCanvas_MouseDown;
            pictureBoxCanvas.MouseMove += PictureBoxCanvas_MouseMove;
            pictureBoxCanvas.MouseUp += PictureBoxCanvas_MouseUp;
            pictureBoxCanvas.Paint += PictureBoxCanvas_Paint;
            pictureBoxCanvas.DoubleClick += PictureBoxCanvas_DoubleClick;
            // also handle parent resize to adjust view
            if (pictureBoxCanvas.Parent != null) pictureBoxCanvas.Parent.Resize += (s, e) => { FitPictureBoxToImage(); };
        }

        private void SetTool(Tool t)
        {
            currentTool = t;
            statusTool.Text = "Tool: " + t.ToString();
            UpdateStatus();
        }

        private void BtnOpen_Click(object sender, EventArgs e)
        {
            using (OpenFileDialog ofd = new OpenFileDialog())
            {
                ofd.Filter = "Image Files|*.png;*.jpg;*.jpeg;*.bmp;*.gif";
                if (ofd.ShowDialog() == DialogResult.OK)
                {
                    var img = Image.FromFile(ofd.FileName);
                    originalBitmap?.Dispose();
                    baseBitmap?.Dispose();
                    workingBitmap?.Dispose();
                    displayBitmap?.Dispose();

                    originalBitmap = new Bitmap(img);
                    baseBitmap = new Bitmap(originalBitmap);
                    workingBitmap = GetScaledBitmap(baseBitmap, zoom);
                    // make picture box show scaled image and enable scrolling
                    try
                    {
                        pictureBoxCanvas.SizeMode = PictureBoxSizeMode.Normal;
                        FitPictureBoxToImage();
                        if (previewPanel != null) previewPanel.AutoScroll = true;
                    }
                    catch { }
                    ClearAnnotationStacks();
                    textAnnotations.Clear();
                    selectedText = null;
                    undoStack.Clear();
                    redoStack.Clear();
                    zoom = 1.0f;
                    UpdateStatus();
                }
            }
        }

        private void BtnColor_Click(object sender, EventArgs e)
        {
            using (ColorDialog cd = new ColorDialog())
            {
                if (cd.ShowDialog() == DialogResult.OK)
                {
                    currentColor = cd.Color;
                    UpdateStatus();
                }
            }
        }

        private void BtnFont_Click(object sender, EventArgs e)
        {
            using (FontDialog fd = new FontDialog())
            {
                if (fd.ShowDialog() == DialogResult.OK)
                {
                    // dispose previous font and store a new one based on the dialog
                    try
                    {
                        currentFontSize = (int)fd.Font.Size;
                        cbFontSize.Text = currentFontSize.ToString();
                        currentFont?.Dispose();
                        currentFont = new Font(fd.Font.FontFamily, fd.Font.Size, fd.Font.Style);

                        // if a text is selected, update its font as well
                        if (selectedText != null)
                        {
                            selectedText.Font?.Dispose();
                            selectedText.Font = new Font(fd.Font.FontFamily, fd.Font.Size, fd.Font.Style);
                        }
                    }
                    catch
                    {
                        // ignore and keep existing font on error
                    }
                }
            }
        }

        private void BtnUndo_Click(object sender, EventArgs e)
        {
            if (undoStack.Count > 0)
            {
                // push current state to redo
                redoStack.Push(CloneState(baseBitmap, textAnnotations));

                var state = undoStack.Pop();
                // dispose current baseBitmap and replace
                baseBitmap?.Dispose();
                baseBitmap = state.Bitmap;
                // replace annotations (they already have their fonts copied)
                DisposeAnnotations(textAnnotations);
                textAnnotations = state.Annotations;

                selectedText = null;
                // regenerate workingBitmap from baseBitmap and current zoom
                workingBitmap?.Dispose();
                workingBitmap = GetScaledBitmap(baseBitmap, zoom);
                // draw in Paint; FitPictureBoxToImage will set control size
                FitPictureBoxToImage();
                pictureBoxCanvas.Invalidate();
            }
        }

        private void BtnRedo_Click(object sender, EventArgs e)
        {
            if (redoStack.Count > 0)
            {
                undoStack.Push(CloneState(baseBitmap, textAnnotations));
                var state = redoStack.Pop();
                baseBitmap?.Dispose();
                baseBitmap = state.Bitmap;
                DisposeAnnotations(textAnnotations);
                textAnnotations = state.Annotations;
                selectedText = null;
                workingBitmap?.Dispose();
                workingBitmap = GetScaledBitmap(baseBitmap, zoom);
                FitPictureBoxToImage();
                pictureBoxCanvas.Invalidate();
            }
        }

        private void BtnSave_Click(object sender, EventArgs e)
        {
            if (baseBitmap == null) return;
            using (SaveFileDialog sfd = new SaveFileDialog())
            {
                sfd.Filter = "PNG Image|*.png|JPEG Image|*.jpg";
                if (sfd.ShowDialog() == DialogResult.OK)
                {
                    Bitmap toSave = RasterizeAnnotations();
                    var fmt = System.Drawing.Imaging.ImageFormat.Png;
                    if (sfd.FileName.EndsWith(".jpg", StringComparison.OrdinalIgnoreCase)) fmt = System.Drawing.Imaging.ImageFormat.Jpeg;
                    toSave.Save(sfd.FileName, fmt);
                    toSave.Dispose();
                }
            }
        }

        private void BtnClear_Click(object sender, EventArgs e)
        {
            if (originalBitmap == null) return;
            PushUndo();
            baseBitmap?.Dispose();
            // restore baseBitmap to original loaded image
            baseBitmap = new Bitmap(originalBitmap);
            // clear annotations
            DisposeAnnotations(textAnnotations);
            textAnnotations.Clear();
            // regenerate display
            workingBitmap?.Dispose();
            workingBitmap = GetScaledBitmap(baseBitmap, zoom);
            FitPictureBoxToImage();
            pictureBoxCanvas.Invalidate();
        }

        // Apply and close: set EditedImage and close dialog with OK
        private void ApplyAnnotationsAndClose()
        {
            if (baseBitmap == null)
            {
                MessageBox.Show("No image to apply.", "Info", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // rasterize current annotations onto a copy (do not dispose baseBitmap yet)
            var result = RasterizeAnnotations();

            // provide EditedImage as a copy
            EditedImage?.Dispose();
            EditedImage = new Bitmap(result);
            result.Dispose();

            this.DialogResult = DialogResult.OK;
            this.Close();
        }

        private void PushUndo()
        {
            if (baseBitmap == null) return;
            undoStack.Push(CloneState(baseBitmap, textAnnotations));
            // clear redo
            ClearStates(redoStack);
        }

        private EditorState CloneState(Bitmap bmp, List<TextAnnotation> ann)
        {
            // clone bitmap and deep-copy annotations and fonts
            Bitmap bmpCopy = bmp != null ? new Bitmap(bmp) : null;
            var annCopy = new List<TextAnnotation>();
            foreach (var a in ann)
            {
                var f = a.Font;
                var fcopy = f != null ? new Font(f.FontFamily, f.Size, f.Style) : null;
                annCopy.Add(new TextAnnotation { Text = a.Text, Font = fcopy, Color = a.Color, Location = a.Location });
            }
            return new EditorState(bmpCopy, annCopy);
        }

        private void ClearStates(Stack<EditorState> stack)
        {
            while (stack.Count > 0)
            {
                var s = stack.Pop();
                s.Bitmap?.Dispose();
                DisposeAnnotations(s.Annotations);
            }
        }

        private void ClearAnnotationStacks()
        {
            ClearStates(undoStack);
            ClearStates(redoStack);
        }

        private void DisposeAnnotations(List<TextAnnotation> ann)
        {
            if (ann == null) return;
            foreach (var a in ann)
                a.Font?.Dispose();
        }

        // Convert a point from control (mouse) coordinates to image (bitmap) coordinates
        private Point ControlToImage(Point p)
        {
            if (baseBitmap == null) return p;
            if (displayBitmap == null || baseBitmap.Width == 0 || baseBitmap.Height == 0) return p;
            float scale = (float)displayBitmap.Width / baseBitmap.Width; // displayBitmap maps to baseBitmap
            int imgX = (int)(p.X / scale);
            int imgY = (int)(p.Y / scale);
            imgX = Math.Max(0, Math.Min(baseBitmap.Width - 1, imgX));
            imgY = Math.Max(0, Math.Min(baseBitmap.Height - 1, imgY));
            return new Point(imgX, imgY);
        }

        // Convert image coordinates to control coordinates (where image is displayed inside pictureBox)
        private Point ImageToControl(Point imgPt)
        {
            if (baseBitmap == null || displayBitmap == null) return imgPt;
            float scale = (float)displayBitmap.Width / baseBitmap.Width;
            int x = (int)(imgPt.X * scale);
            int y = (int)(imgPt.Y * scale);
            return new Point(x, y);
        }

        // regenerate workingBitmap from baseBitmap using current zoom
        private Bitmap GetScaledBitmap(Bitmap src, float zoomFactor)
        {
            if (src == null) return null;
            int w = Math.Max(1, (int)(src.Width * zoomFactor));
            int h = Math.Max(1, (int)(src.Height * zoomFactor));
            var nb = new Bitmap(w, h);
            using (Graphics g = Graphics.FromImage(nb))
            {
                g.InterpolationMode = InterpolationMode.HighQualityBicubic;
                g.DrawImage(src, 0, 0, w, h);
            }
            return nb;
        }

        // fit pictureBox to image size and enable scrolling or centering
        private void FitPictureBoxToImage()
        {
            if (workingBitmap == null) return;

            // compute available preview rectangle (between toolStripTop and statusStripBottom)
            int availX = 0;
            int availY = toolStripTop.Bottom;
            int availW = this.ClientSize.Width;
            int availH = this.ClientSize.Height - toolStripTop.Height - statusStripBottom.Height;
            if (availW <= 0 || availH <= 0) return;

            // dispose previous displayBitmap
            displayBitmap?.Dispose();
            displayBitmap = null;

            // If image larger than available area, show full-size workingBitmap and enable scrolling
            if (workingBitmap.Width > availW || workingBitmap.Height > availH)
            {
                displayBitmap = new Bitmap(workingBitmap);
                pictureBoxCanvas.Width = displayBitmap.Width;
                pictureBoxCanvas.Height = displayBitmap.Height;
                pictureBoxCanvas.Image = displayBitmap;

                // position under toolStrip
                pictureBoxCanvas.Left = availX;
                pictureBoxCanvas.Top = availY;

                var sc = pictureBoxCanvas.Parent as ScrollableControl;
                if (sc != null)
                {
                    sc.AutoScroll = true;
                }
            }
            else
            {
                // image fits within area - center and disable scrolling
                float scale = Math.Min((float)availW / workingBitmap.Width, (float)availH / workingBitmap.Height);
                int newW = (int)(workingBitmap.Width * scale);
                int newH = (int)(workingBitmap.Height * scale);
                displayBitmap = new Bitmap(workingBitmap, new Size(newW, newH));

                pictureBoxCanvas.Width = displayBitmap.Width;
                pictureBoxCanvas.Height = displayBitmap.Height;
                pictureBoxCanvas.Image = displayBitmap;

                int left = availX + (availW - displayBitmap.Width) / 2;
                int top = availY + (availH - displayBitmap.Height) / 2;
                pictureBoxCanvas.Left = Math.Max(0, left);
                pictureBoxCanvas.Top = Math.Max(toolStripTop.Bottom, top);

                var sc = pictureBoxCanvas.Parent as ScrollableControl;
                if (sc != null) sc.AutoScroll = false;
            }

            // Ensure toolstrip and statusstrip remain on top
            try
            {
                toolStripTop.BringToFront();
                statusStripBottom.BringToFront();
            }
            catch { }
        }

        private void PictureBoxCanvas_MouseDown(object sender, MouseEventArgs e)
        {
            if (baseBitmap == null) return;
            isDrawing = true;
            // convert to image coords (mouse event e.Location is pictureBox-local)
            lastPoint = ControlToImage(e.Location);

            if (currentTool == Tool.Select)
            {
                // check if click is on a text annotation using control coordinates
                var hit = GetAnnotationAt(e.Location);
                if (hit != null)
                {
                    // push undo so move can be undone
                    PushUndo();
                    selectedText = hit;
                    isDraggingText = true;
                    // compute drag offset in control coords (mouse - annotation control top-left)
                    var topLeft = ImageToControl(hit.Location);
                    dragOffset = new Point(e.X - topLeft.X, e.Y - topLeft.Y);
                }
                else
                {
                    selectedText = null;
                    isDraggingText = false;
                }
            }
            else
            {
                if (currentTool == Tool.Pencil || currentTool == Tool.Rectangle || currentTool == Tool.Circle || currentTool == Tool.Arrow || currentTool == Tool.Text)
                    PushUndo();
            }
        }

        private void PictureBoxCanvas_MouseMove(object sender, MouseEventArgs e)
        {
            if (baseBitmap == null) return;
            statusCoords.Text = $"X:{e.X} Y:{e.Y}";
            if (!isDrawing) return;

            if (isDraggingText && selectedText != null)
            {
                // compute new top-left in control coords, then convert to image coords
                var newTopLeftControl = new Point(e.X - dragOffset.X, e.Y - dragOffset.Y);
                selectedText.Location = ControlToImage(newTopLeftControl);
                pictureBoxCanvas.Invalidate();
                return;
            }

            if (currentTool == Tool.Pencil)
            {
                var imgPt = ControlToImage(e.Location);
                using (Graphics g = Graphics.FromImage(baseBitmap))
                {
                    g.SmoothingMode = SmoothingMode.AntiAlias;
                    using (Pen p = new Pen(currentColor, 2))
                        g.DrawLine(p, lastPoint, imgPt);
                }
                lastPoint = imgPt;
                // regenerate workingBitmap and redisplay
                workingBitmap?.Dispose();
                workingBitmap = GetScaledBitmap(baseBitmap, zoom);
                FitPictureBoxToImage();
                pictureBoxCanvas.Invalidate();
            }
            else
            {
                // preview handled in Paint (uses control coords mapped from image coords)
                pictureBoxCanvas.Invalidate();
            }
        }

        private void PictureBoxCanvas_MouseUp(object sender, MouseEventArgs e)
        {
            if (baseBitmap == null) return;
            isDrawing = false;

            if (isDraggingText)
            {
                // finish dragging
                isDraggingText = false;
                selectedText = null;
                pictureBoxCanvas.Invalidate();
                return;
            }

            var imgPt = ControlToImage(e.Location);

            if (currentTool == Tool.Rectangle)
            {
                var r = GetRect(lastPoint, imgPt);
                using (Graphics g = Graphics.FromImage(baseBitmap))
                {
                    using (Pen p = new Pen(currentColor, 2)) g.DrawRectangle(p, r);
                }
                workingBitmap?.Dispose();
                workingBitmap = GetScaledBitmap(baseBitmap, zoom);
                FitPictureBoxToImage();
                pictureBoxCanvas.Invalidate();
            }
            else if (currentTool == Tool.Circle)
            {
                var r = GetRect(lastPoint, imgPt);
                using (Graphics g = Graphics.FromImage(baseBitmap))
                {
                    using (Pen p = new Pen(currentColor, 2)) g.DrawEllipse(p, r);
                }
                workingBitmap?.Dispose();
                workingBitmap = GetScaledBitmap(baseBitmap, zoom);
                FitPictureBoxToImage();
                pictureBoxCanvas.Invalidate();
            }
            else if (currentTool == Tool.Arrow)
            {
                DrawArrowOnBitmap(lastPoint, imgPt);
                workingBitmap?.Dispose();
                workingBitmap = GetScaledBitmap(baseBitmap, zoom);
                FitPictureBoxToImage();
                pictureBoxCanvas.Invalidate();
            }
            else if (currentTool == Tool.Text)
            {
                string txt = PromptText("Enter text:", string.Empty);
                if (!string.IsNullOrEmpty(txt))
                {
                    // add annotation (do not rasterize immediately); store location in image coords
                    var a = new TextAnnotation { Text = txt, Font = new Font(currentFont.FontFamily, currentFont.Size, currentFont.Style), Color = currentColor, Location = imgPt };
                    textAnnotations.Add(a);
                    pictureBoxCanvas.Invalidate();
                }
            }
            UpdateStatus();
        }

        private void PictureBoxCanvas_Paint(object sender, PaintEventArgs e)
        {
            if (displayBitmap == null) return; // use displayBitmap for drawing overlays

            // draw preview shapes and annotations on top of displayed image
            if (isDrawing && (currentTool == Tool.Rectangle || currentTool == Tool.Circle || currentTool == Tool.Arrow))
            {
                // draw preview: lastPoint and current mouse converted to control coords
                var mouseControl = pictureBoxCanvas.PointToClient(Cursor.Position);
                var startControl = ImageToControl(lastPoint);
                var r = GetRect(startControl, mouseControl);
                using (Pen p = new Pen(currentColor, 2))
                {
                    e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;
                    if (currentTool == Tool.Rectangle) e.Graphics.DrawRectangle(p, r);
                    else if (currentTool == Tool.Circle) e.Graphics.DrawEllipse(p, r);
                    else if (currentTool == Tool.Arrow) DrawArrow(e.Graphics, startControl, mouseControl, p);
                }
            }

            // Draw text annotations on top (not rasterized to bitmap until save/apply)
            foreach (var a in textAnnotations)
            {
                var dispPt = ImageToControl(a.Location);
                float scale = (displayBitmap != null && baseBitmap != null) ? (float)displayBitmap.Width / baseBitmap.Width : 1f;
                using (Font drawFont = new Font(a.Font.FontFamily, Math.Max(1f, a.Font.Size * scale), a.Font.Style))
                using (Brush b = new SolidBrush(a.Color))
                {
                    e.Graphics.TextRenderingHint = System.Drawing.Text.TextRenderingHint.ClearTypeGridFit;
                    e.Graphics.DrawString(a.Text, drawFont, b, dispPt);
                }
            }
        }

        private void PictureBoxCanvas_DoubleClick(object sender, EventArgs e)
        {
            var me = e as MouseEventArgs;
            Point p;
            if (me != null) p = me.Location; else p = pictureBoxCanvas.PointToClient(Cursor.Position);

            var hit = GetAnnotationAt(p);
            if (hit != null)
            {
                // allow editing text
                PushUndo();
                string res = PromptText("Edit text:", hit.Text);
                if (res != null)
                {
                    hit.Text = res;
                    pictureBoxCanvas.Invalidate();
                }
            }
        }

        private Rectangle GetRect(Point p1, Point p2)
        {
            return new Rectangle(Math.Min(p1.X, p2.X), Math.Min(p1.Y, p2.Y), Math.Abs(p1.X - p2.X), Math.Abs(p1.Y - p2.Y));
        }

        private void DrawArrowOnBitmap(Point p1, Point p2)
        {
            using (Graphics g = Graphics.FromImage(baseBitmap))
            using (Pen p = new Pen(currentColor, 2))
            {
                g.SmoothingMode = SmoothingMode.AntiAlias;
                DrawArrow(g, p1, p2, p);
            }
        }

        private void DrawArrow(Graphics g, Point p1, Point p2, Pen p)
        {
            g.DrawLine(p, p1, p2);
            var ang = Math.Atan2(p2.Y - p1.Y, p2.X - p1.X);
            int len = 10;
            PointF p3 = new PointF((float)(p2.X - len * Math.Cos(ang) + len * Math.Sin(ang)), (float)(p2.Y - len * Math.Sin(ang) - len * Math.Cos(ang)));
            PointF p4 = new PointF((float)(p2.X - len * Math.Cos(ang) - len * Math.Sin(ang)), (float)(p2.Y - len * Math.Sin(ang) + len * Math.Cos(ang)));
            g.FillPolygon(new SolidBrush(p.Color), new PointF[] { p2, p3, p4 });
        }

        private TextAnnotation GetAnnotationAt(Point controlPoint)
        {
            // check from topmost (last) to bottom
            for (int i = textAnnotations.Count - 1; i >= 0; i--)
            {
                var a = textAnnotations[i];
                if (a == null) continue;
                // compute display location and scaled font
                var dispPt = ImageToControl(a.Location);
                float scale = (displayBitmap != null && baseBitmap != null) ? (float)displayBitmap.Width / baseBitmap.Width : 1f;
                using (var f = new Font(a.Font.FontFamily, Math.Max(1f, a.Font.Size * scale), a.Font.Style))
                {
                    var size = TextRenderer.MeasureText(a.Text, f);
                    var rect = new Rectangle(dispPt, size);
                    if (rect.Contains(controlPoint)) return a;
                }
            }
            return null;
        }

        private string PromptText(string prompt, string initial)
        {
            using (Form f = new Form())
            using (TextBox tb = new TextBox() { Left = 10, Top = 30, Width = 360, Text = initial })
            using (Button ok = new Button() { Text = "OK", Left = 200, Width = 80, Top = 60, DialogResult = DialogResult.OK })
            using (Button cancel = new Button() { Text = "Cancel", Left = 290, Width = 80, Top = 60, DialogResult = DialogResult.Cancel })
            {
                f.Text = prompt;
                f.ClientSize = new Size(400, 110);
                f.Controls.Add(new Label() { Left = 10, Top = 8, Text = prompt, AutoSize = true });
                f.Controls.Add(tb);
                f.Controls.Add(ok);
                f.Controls.Add(cancel);
                f.AcceptButton = ok;
                f.CancelButton = cancel;
                return f.ShowDialog(this) == DialogResult.OK ? tb.Text : null;
            }
        }

        private Bitmap RasterizeAnnotations()
        {
            // draw current baseBitmap and all text annotations into a new bitmap
            Bitmap bmp = new Bitmap(baseBitmap.Width, baseBitmap.Height);
            using (Graphics g = Graphics.FromImage(bmp))
            {
                g.DrawImage(baseBitmap, 0, 0);
                g.SmoothingMode = SmoothingMode.AntiAlias;
                foreach (var a in textAnnotations)
                {
                    using (Brush b = new SolidBrush(a.Color))
                    {
                        g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.ClearTypeGridFit;
                        g.DrawString(a.Text, a.Font, b, a.Location);
                    }
                }
            }
            return bmp;
        }

        private void ApplyZoom()
        {
            if (baseBitmap == null) return;
            // regenerate workingBitmap using baseBitmap and zoom
            workingBitmap?.Dispose();
            workingBitmap = GetScaledBitmap(baseBitmap, zoom);
            FitPictureBoxToImage();
            statusZoom.Text = $"Zoom: {(int)(zoom * 100)}%";
            pictureBoxCanvas.Invalidate();
        }

        private void UpdateStatus()
        {
            statusTool.Text = "Tool: " + currentTool.ToString();
            statusZoom.Text = $"Zoom: {(int)(zoom * 100)}%";
            // coords left as 0 until mouse move
        }
    }
}
