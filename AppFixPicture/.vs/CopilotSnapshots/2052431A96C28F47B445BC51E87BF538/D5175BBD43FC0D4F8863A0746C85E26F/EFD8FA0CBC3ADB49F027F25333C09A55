using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace AppFixPicture
{
    public partial class FormCrop : Form
    {
        // Thuộc tính để nhận ảnh từ Form1
        public Bitmap ImageToCrop { get; set; }

        // Thuộc tính để trả về ảnh đã cắt về Form1
        public Bitmap ResultImage { get; private set; }
        // Biến cho chức năng Crop
        private bool isSelecting = false; // Trạng thái đang chọn vùng cắt
        private Point startPoint;         // Vị trí bắt đầu (MouseDown)
        private Rectangle selectionRect;  // Vùng chữ nhật được chọn

        // Tỷ lệ chuyển đổi tọa độ (quan trọng cho PictureBox Mode = Zoom)
        private float zoomRatio = 1.0f;
        private Bitmap workingImage;
        private Bitmap rotationBaseImage;

        // Lưu trữ góc xoay hiện tại (cần thiết cho logic Apply)
        private int currentRotationAngle = 0;
        public FormCrop()
        {
            InitializeComponent();
            this.Load += FormCrop_Load;
        }

        private void FormCrop_Load(object sender, EventArgs e)
        {
            if (ImageToCrop != null)
            {
                // Khởi tạo ảnh làm việc bằng một bản sao của ảnh gốc
                workingImage = new Bitmap(ImageToCrop);

                pictureBoxCrop.Image = workingImage;
                pictureBoxCrop.SizeMode = PictureBoxSizeMode.Zoom;
            }
            if (ImageToCrop != null)
            {
                // Hiển thị ảnh trong PictureBox của FormCrop
                pictureBoxCrop.Image = ImageToCrop;
                // Cần thiết lập chế độ zoom/stretch cho pictureBoxCrop
                // Ví dụ: pictureBoxCrop.SizeMode = PictureBoxSizeMode.Zoom;
            }
            if (ImageToCrop != null)
            {
                // 1. Ảnh gốc ban đầu
                workingImage = new Bitmap(ImageToCrop);

                // 2. Gán ảnh gốc cho biến base để xoay (rất quan trọng)
                rotationBaseImage = new Bitmap(ImageToCrop);

                pictureBoxCrop.Image = workingImage;
                // ... (Thiết lập PictureBoxMode.Zoom và tính zoomRatio) ...

                // 3. Thiết lập TrackBar và Label
                trackBarRotation.Value = 0;
                lblRotationValue.Text = "0°";
            }
            if (ImageToCrop != null)
            {
                pictureBoxCrop.Image = ImageToCrop;

                // **QUAN TRỌNG:** Thiết lập chế độ Zoom và tính tỉ lệ Zoom
                pictureBoxCrop.SizeMode = PictureBoxSizeMode.Zoom;

                // Tính zoomRatio (chỉ cần tính 1 lần khi load ảnh)
                float ratioW = (float)pictureBoxCrop.Width / ImageToCrop.Width;
                float ratioH = (float)pictureBoxCrop.Height / ImageToCrop.Height;

                // Dùng tỉ lệ nhỏ nhất để đảm bảo ảnh vừa khung hình (Mode.Zoom)
                zoomRatio = Math.Min(ratioW, ratioH);
            }
        }

        private void pictureBoxCrop_Click(object sender, EventArgs e)
        {

        }

        private void pictureBoxCrop_MouseDown(object sender, MouseEventArgs e)
        {
            if (ImageToCrop == null) return;

            isSelecting = true;
            startPoint = e.Location;
            selectionRect = Rectangle.Empty;

            // Bắt đầu vẽ
            pictureBoxCrop.Invalidate();
        }

        private void pictureBoxCrop_MouseMove(object sender, MouseEventArgs e)
        {
            if (!isSelecting) return;

            // Tính toán kích thước và vị trí của vùng chọn
            int x = Math.Min(startPoint.X, e.X);
            int y = Math.Min(startPoint.Y, e.Y);
            int w = Math.Abs(startPoint.X - e.X);
            int h = Math.Abs(startPoint.Y - e.Y);

            selectionRect = new Rectangle(x, y, w, h);

            // Yêu cầu PictureBox vẽ lại
            pictureBoxCrop.Invalidate();
        }

        private void pictureBoxCrop_MouseUp(object sender, MouseEventArgs e)
        {
            isSelecting = false;
        }

        private void pictureBoxCrop_Paint(object sender, PaintEventArgs e)
        {
            if (selectionRect != Rectangle.Empty)
            {
                // Vẽ khung nét đứt màu trắng (hoặc màu đỏ)
                using (Pen pen = new Pen(Color.White, 2) { DashStyle = System.Drawing.Drawing2D.DashStyle.Dash })
                {
                    e.Graphics.DrawRectangle(pen, selectionRect);
                }
            }
        }

        private void btnCancel_Click(object sender, EventArgs e)
        {
            this.DialogResult = DialogResult.Cancel;
            this.Close();
        }

        private void btnApply_Click(object sender, EventArgs e)
        {
            // Trường hợp 1: Người dùng đã thực hiện thao tác kéo chuột để chọn vùng
            if (!selectionRect.IsEmpty && selectionRect.Width >= 5 && selectionRect.Height >= 5)
            {
                // === LOGIC CẮT THỦ CÔNG (MANUAL CROP) ===
                try
                {
                    // Cần kiểm tra workingImage
                    if (workingImage == null)
                    {
                        MessageBox.Show("Không có ảnh để cắt.", "Lỗi");
                        return;
                    }

                    // 1. Tính toán Offset để căn chỉnh (vì PictureBoxMode.Zoom)
                    int displayedImageW = (int)(workingImage.Width * zoomRatio);
                    int displayedImageH = (int)(workingImage.Height * zoomRatio);

                    int offsetX = (pictureBoxCrop.Width - displayedImageW) / 2;
                    int offsetY = (pictureBoxCrop.Height - displayedImageH) / 2;

                    // 2. Chuyển đổi tọa độ từ PictureBox sang tọa độ ảnh gốc (pixel)
                    int cropX = (int)((selectionRect.X - offsetX) / zoomRatio);
                    int cropY = (int)((selectionRect.Y - offsetY) / zoomRatio);
                    int cropW = (int)(selectionRect.Width / zoomRatio);
                    int cropH = (int)(selectionRect.Height / zoomRatio);

                    // 3. Đảm bảo vùng cắt nằm trong giới hạn của ảnh
                    cropX = Math.Max(0, cropX);
                    cropY = Math.Max(0, cropY);
                    cropW = Math.Min(workingImage.Width - cropX, cropW);
                    cropH = Math.Min(workingImage.Height - cropY, cropH);

                    Rectangle cropArea = new Rectangle(cropX, cropY, cropW, cropH);

                    // 4. Thực hiện Crop
                    if (cropArea.Width > 0 && cropArea.Height > 0)
                    {
                        // **QUAN TRỌNG: Cắt ảnh dựa trên workingImage**
                        Bitmap croppedBitmap = workingImage.Clone(cropArea, workingImage.PixelFormat);

                        // Gán kết quả cuối cùng cho ResultImage
                        ResultImage = croppedBitmap;
                        this.DialogResult = DialogResult.OK;
                        this.Close();
                    }
                    else
                    {
                        MessageBox.Show("Vùng cắt không hợp lệ hoặc quá nhỏ.", "Thông báo");
                    }
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"Lỗi trong quá trình cắt thủ công: {ex.Message}");
                }
            }
            // Trường hợp 2: Người dùng vừa nhấn Auto Crop (hoặc đã có workingImage) và không kéo chuột thêm
            else if (workingImage != null)
            {
                // Xác nhận ảnh hiện tại (đã qua Auto Crop) là kết quả cuối cùng
                ResultImage = workingImage;
                this.DialogResult = DialogResult.OK;
                this.Close();
            }
            // Trường hợp 3: Chưa có ảnh hoặc không có hành động nào
            else
            {
                MessageBox.Show("Chưa có ảnh được tải hoặc vùng cắt hợp lệ nào được chọn/áp dụng.", "Thông Báo");
            }
        }

        private void btnAutoCrop43_Click(object sender, EventArgs e)
        {
            // Tỷ lệ mong muốn: 4:3 (W:H)
            const float TARGET_RATIO = 4.0f / 3.0f;

            if (ImageToCrop == null)
            {
                MessageBox.Show("Không có ảnh để cắt.", "Lỗi");
                return;
            }

            Bitmap original = ImageToCrop;
            int originalW = original.Width;
            int originalH = original.Height;
            float originalRatio = (float)originalW / originalH;

            Rectangle cropArea;

            if (originalRatio > TARGET_RATIO)
            {
                int newW = (int)(originalH * TARGET_RATIO);
                int offsetX = (originalW - newW) / 2;
                cropArea = new Rectangle(offsetX, 0, newW, originalH);
            }
            else
            {
                int newH = (int)(originalW / TARGET_RATIO);
                int offsetY = (originalH - newH) / 2;
                cropArea = new Rectangle(0, offsetY, originalW, newH);
            }

            try
            {
                if (cropArea.Width > 0 && cropArea.Height > 0)
                {
                    // Cắt trên ảnh hiện tại
                    Bitmap croppedBitmap = workingImage.Clone(cropArea, workingImage.PixelFormat);

                    // QUAN TRỌNG: Giải phóng ảnh cũ và gán ảnh mới đã cắt vào workingImage
                    if (workingImage != null) workingImage.Dispose();
                    workingImage = croppedBitmap;

                    // Hiển thị ảnh mới
                    pictureBoxCrop.Image = workingImage;

                    // Reset vùng chọn thủ công
                    selectionRect = Rectangle.Empty;
                    isSelecting = false;
                    pictureBoxCrop.Invalidate();

                    MessageBox.Show("Ảnh đã được cắt tự động 4:3. Vui lòng nhấn 'Áp dụng' để xác nhận hoặc kéo chuột để cắt tiếp.", "Thông Báo");
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Lỗi trong quá trình cắt tự động: {ex.Message}");
            }
        }

        private void btnAutoCrop11_Click(object sender, EventArgs e)
        {
            // Tỷ lệ mong muốn: 1:1 (Hình vuông)
            const float TARGET_RATIO = 1.0f; // 1.0f / 1.0f

            if (workingImage == null)
            {
                MessageBox.Show("Không có ảnh để cắt. Vui lòng tải ảnh lên Form chính trước.", "Lỗi");
                return;
            }

            Bitmap currentImage = workingImage;
            int originalW = currentImage.Width;
            int originalH = currentImage.Height;
            float originalRatio = (float)originalW / originalH;

            Rectangle cropArea;

            if (originalRatio > TARGET_RATIO) // Ảnh rộng hơn (W > H) -> Cắt theo Chiều cao
            {
                /*
                 * Giữ nguyên Chiều cao (H), tính lại Chiều rộng (W) = H
                 * Vùng cắt sẽ là hình vuông có cạnh = H, được căn giữa theo chiều ngang.
                 */

                int newSize = originalH; // Chiều dài cạnh hình vuông = Chiều cao ảnh gốc
                int offsetX = (originalW - newSize) / 2; // Khoảng offset để căn giữa

                cropArea = new Rectangle(
                    offsetX,
                    0,
                    newSize,
                    newSize // Chiều cao cũng bằng newSize
                );
            }
            else // Ảnh cao hơn (H > W) hoặc bằng (H = W) -> Cắt theo Chiều rộng
            {
                /*
                 * Giữ nguyên Chiều rộng (W), tính lại Chiều cao (H) = W
                 * Vùng cắt sẽ là hình vuông có cạnh = W, được căn giữa theo chiều dọc.
                 */

                int newSize = originalW; // Chiều dài cạnh hình vuông = Chiều rộng ảnh gốc
                int offsetY = (originalH - newSize) / 2; // Khoảng offset để căn giữa

                cropArea = new Rectangle(
                    0,
                    offsetY,
                    newSize,
                    newSize // Chiều cao cũng bằng newSize
                );
            }

            // 3. Thực hiện Crop và cập nhật trạng thái xem trước
            try
            {
                if (cropArea.Width > 0 && cropArea.Height > 0)
                {
                    // Cắt trên ảnh hiện tại (workingImage)
                    Bitmap croppedBitmap = currentImage.Clone(cropArea, currentImage.PixelFormat);

                    // QUAN TRỌNG: Giải phóng ảnh cũ và gán ảnh mới đã cắt vào workingImage
                    if (workingImage != null) workingImage.Dispose();
                    workingImage = croppedBitmap;

                    // Hiển thị ảnh mới để xem trước
                    pictureBoxCrop.Image = workingImage;

                    // Reset vùng chọn thủ công
                    selectionRect = Rectangle.Empty;
                    isSelecting = false;
                    pictureBoxCrop.Invalidate();

                    MessageBox.Show("Ảnh đã được cắt tự động 1:1. Vui lòng nhấn 'Áp dụng' để xác nhận.", "Thông Báo");
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Lỗi trong quá trình cắt tự động 1:1: {ex.Message}");
            }
        }
        private Bitmap CropImageToCircle(Bitmap srcSquareImage)
        {
            // Tạo Bitmap mới với nền trong suốt (Format32bppArgb)
            Bitmap croppedCircle = new Bitmap(srcSquareImage.Width, srcSquareImage.Height, System.Drawing.Imaging.PixelFormat.Format32bppArgb);

            // Sử dụng Graphics để vẽ hình tròn (mask)
            using (Graphics g = Graphics.FromImage(croppedCircle))
            {
                // Đặt chất lượng cao để đường tròn mịn
                g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias;

                // Tạo đường dẫn hình tròn
                using (System.Drawing.Drawing2D.GraphicsPath gp = new System.Drawing.Drawing2D.GraphicsPath())
                {
                    // Kích thước của hình tròn là toàn bộ kích thước ảnh vuông
                    gp.AddEllipse(0, 0, srcSquareImage.Width, srcSquareImage.Height);

                    // Cắt vùng Graphics theo hình tròn
                    g.SetClip(gp);

                    // Vẽ ảnh vuông lên vùng đã cắt (hình tròn)
                    g.DrawImage(srcSquareImage, 0, 0);
                }
            }

            return croppedCircle;
        }

        private void btnAutoCropCircle_Click(object sender, EventArgs e)
        {
            if (workingImage == null)
            {
                MessageBox.Show("Không có ảnh để cắt.", "Lỗi");
                return;
            }

            Bitmap currentImage = workingImage;
            int originalW = currentImage.Width;
            int originalH = currentImage.Height;
            float originalRatio = (float)originalW / originalH;
            const float TARGET_RATIO = 1.0f; // Luôn cần cắt thành hình vuông trước

            Rectangle cropArea;

            // 1. Tính toán vùng cắt hình vuông lớn nhất có thể và căn giữa
            if (originalRatio > TARGET_RATIO) // Ảnh rộng hơn (W > H) -> Cắt theo Chiều cao
            {
                int newSize = originalH;
                int offsetX = (originalW - newSize) / 2;
                cropArea = new Rectangle(offsetX, 0, newSize, newSize);
            }
            else // Ảnh cao hơn (H > W) hoặc bằng (H = W) -> Cắt theo Chiều rộng
            {
                int newSize = originalW;
                int offsetY = (originalH - newSize) / 2;
                cropArea = new Rectangle(0, offsetY, newSize, newSize);
            }

            // 2. Thực hiện Crop và cập nhật trạng thái
            try
            {
                if (cropArea.Width > 0 && cropArea.Height > 0)
                {
                    // Cắt ảnh thành hình vuông
                    Bitmap croppedSquareBitmap = currentImage.Clone(cropArea, currentImage.PixelFormat);

                    // **Áp dụng mặt nạ hình tròn**
                    Bitmap croppedCircleBitmap = CropImageToCircle(croppedSquareBitmap);

                    // Giải phóng ảnh tạm
                    croppedSquareBitmap.Dispose();

                    // QUAN TRỌNG: Giải phóng ảnh cũ và gán ảnh mới đã cắt vào workingImage
                    if (workingImage != null) workingImage.Dispose();
                    workingImage = croppedCircleBitmap;

                    // Hiển thị ảnh mới để xem trước
                    pictureBoxCrop.Image = workingImage;

                    // Reset vùng chọn thủ công
                    selectionRect = Rectangle.Empty;
                    isSelecting = false;
                    pictureBoxCrop.Invalidate();

                    MessageBox.Show("Ảnh đã được cắt tự động thành hình tròn. Vui lòng nhấn 'Áp dụng' để xác nhận.", "Thông Báo");
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Lỗi trong quá trình cắt tự động hình tròn: {ex.Message}");
            }
        }

        private void btnResetCrop_Click(object sender, EventArgs e)
        {
            if (ImageToCrop == null)
            {
                MessageBox.Show("Không có ảnh gốc để reset.", "Thông báo");
                return;
            }

            // 1. Giải phóng workingImage hiện tại (nếu có)
            if (workingImage != null)
            {
                // QUAN TRỌNG: Kiểm tra xem workingImage có phải là cùng một tham chiếu với ImageToCrop không
                // Nếu không phải, chúng ta cần giải phóng nó
                if (workingImage != ImageToCrop)
                {
                    workingImage.Dispose();
                }
            }

            // 2. Tạo một bản sao mới của ảnh gốc ban đầu (ImageToCrop)
            workingImage = new Bitmap(ImageToCrop);
            if (rotationBaseImage != null) rotationBaseImage.Dispose();
            rotationBaseImage = new Bitmap(ImageToCrop);

            // 3. Reset góc xoay
            currentRotationAngle = 0;
            trackBarRotation.Value = 0;
            lblRotationValue.Text = "0°";

            // 3. Cập nhật PictureBox để hiển thị ảnh gốc
            pictureBoxCrop.Image = workingImage;

            // 4. Reset các trạng thái chỉnh sửa
            selectionRect = Rectangle.Empty; // Xóa vùng chọn thủ công
            isSelecting = false;
            pictureBoxCrop.Invalidate();
            pictureBoxCrop.Image = workingImage;
            RecalculateZoomRatio(); // Tính toán lại ZoomRatio sau Reset
            selectionRect = Rectangle.Empty;
            isSelecting = false;
            ResultImage = null;
            pictureBoxCrop.Invalidate();
            // 5. Reset ResultImage (vì chúng ta chưa nhấn Apply)
            ResultImage = null;

            MessageBox.Show("Ảnh đã được khôi phục về trạng thái ban đầu.", "Thông Báo");
        }

        private void btnFlipHorizontal_Click(object sender, EventArgs e)
        {
            if (workingImage == null)
            {
                MessageBox.Show("Không có ảnh để lật.", "Lỗi");
                return;
            }

            try
            {
                // 1. Áp dụng thao tác lật ngang trực tiếp lên workingImage
                // Lật ảnh theo trục Y (ngang)
                workingImage.RotateFlip(RotateFlipType.RotateNoneFlipX);

                // 2. Cập nhật hiển thị
                pictureBoxCrop.Image = workingImage;
                pictureBoxCrop.Invalidate();

                // 3. Reset các trạng thái chỉnh sửa
                selectionRect = Rectangle.Empty;
                isSelecting = false;
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Lỗi trong quá trình lật ngang: {ex.Message}", "Lỗi Lật Ảnh");
            }
        }

        private void btnFlipVertical_Click(object sender, EventArgs e)
        {
            if (workingImage == null)
            {
                MessageBox.Show("Không có ảnh để lật.", "Lỗi");
                return;
            }

            try
            {
                // 1. Áp dụng thao tác lật dọc trực tiếp lên workingImage
                // Lật ảnh theo trục X (dọc)
                workingImage.RotateFlip(RotateFlipType.RotateNoneFlipY);

                // 2. Cập nhật hiển thị
                pictureBoxCrop.Image = workingImage;
                pictureBoxCrop.Invalidate();

                // 3. Reset các trạng thái chỉnh sửa
                selectionRect = Rectangle.Empty;
                isSelecting = false;
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Lỗi trong quá trình lật dọc: {ex.Message}", "Lỗi Lật Ảnh");
            }
        }

        private void btnRotateRight_Click(object sender, EventArgs e)
        {
            if (workingImage == null)
            {
                MessageBox.Show("Không có ảnh để xoay.", "Lỗi");
                return;
            }

            try
            {
                // 1. Áp dụng thao tác xoay phải 90 độ
                workingImage.RotateFlip(RotateFlipType.Rotate90FlipNone);

                // 2. Cập nhật hiển thị
                pictureBoxCrop.Image = workingImage;
                pictureBoxCrop.Invalidate();

                // 3. Reset các trạng thái chỉnh sửa
                selectionRect = Rectangle.Empty;
                isSelecting = false;

                // QUAN TRỌNG: Cần tính toán lại zoomRatio nếu kích thước ảnh đã thay đổi (W và H đảo chỗ)
                // Nên gọi lại logic tính toán zoomRatio sau khi xoay (ví dụ: FormCrop_Load logic)
                RecalculateZoomRatio();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Lỗi trong quá trình xoay phải: {ex.Message}", "Lỗi Xoay Ảnh");
            }

        }

        private void btnRotateLeft_Click(object sender, EventArgs e)
        {
            if (workingImage == null)
            {
                MessageBox.Show("Không có ảnh để xoay.", "Lỗi");
                return;
            }

            try
            {
                // 1. Áp dụng thao tác xoay trái 90 độ (tương đương Rotate270FlipNone)
                workingImage.RotateFlip(RotateFlipType.Rotate270FlipNone);

                // 2. Cập nhật hiển thị
                pictureBoxCrop.Image = workingImage;
                pictureBoxCrop.Invalidate();

                // 3. Reset các trạng thái chỉnh sửa
                selectionRect = Rectangle.Empty;
                isSelecting = false;

                // QUAN TRỌNG: Cần tính toán lại zoomRatio nếu kích thước ảnh đã thay đổi
                RecalculateZoomRatio();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Lỗi trong quá trình xoay trái: {ex.Message}", "Lỗi Xoay Ảnh");
            }
        }
        private void RecalculateZoomRatio()
        {
            if (workingImage == null)
            {
                zoomRatio = 1.0f;
                return;
            }

            // Tính lại zoomRatio dựa trên kích thước mới của workingImage
            float ratioW = (float)pictureBoxCrop.Width / workingImage.Width;
            float ratioH = (float)pictureBoxCrop.Height / workingImage.Height;

            // Dùng tỉ lệ nhỏ nhất (vì PictureBoxMode.Zoom)
            zoomRatio = Math.Min(ratioW, ratioH);
        }

        private void trackBarRotation_Scroll(object sender, EventArgs e)
        {
            if (rotationBaseImage == null) return;

            // Lấy góc xoay mới từ TrackBar
            currentRotationAngle = trackBarRotation.Value;

            // Cập nhật Label
            lblRotationValue.Text = $"{currentRotationAngle}°";

            // Thực hiện xoay ảnh
            Bitmap newRotatedImage = RotateImage(rotationBaseImage, currentRotationAngle);

            // Giải phóng workingImage cũ
            if (workingImage != null) workingImage.Dispose();

            // Gán ảnh xoay mới
            workingImage = newRotatedImage;
            pictureBoxCrop.Image = workingImage;

            // Cần tính toán lại zoomRatio vì kích thước ảnh sau khi xoay có thể thay đổi
            RecalculateZoomRatio();

            // Reset vùng chọn (vì vùng chọn cũ không còn chính xác)
            selectionRect = Rectangle.Empty;
            pictureBoxCrop.Invalidate();
        }
        private Bitmap RotateImage(Bitmap baseImage, float angle)
        {
            // Nếu góc là 0, trả về bản sao của ảnh gốc
            if (angle == 0) return new Bitmap(baseImage);

            // 1. Chuyển góc độ sang Radian và tính toán kích thước mới
            double radianAngle = angle * Math.PI / 180.0;

            // Tính toán kích thước ảnh mới để chứa toàn bộ ảnh gốc sau khi xoay
            float sin = (float)Math.Abs(Math.Sin(radianAngle));
            float cos = (float)Math.Abs(Math.Cos(radianAngle));
            int newWidth = (int)(baseImage.Width * cos + baseImage.Height * sin);
            int newHeight = (int)(baseImage.Width * sin + baseImage.Height * cos);

            // 2. Tạo Bitmap mới với kích thước đã tính toán và nền trong suốt
            Bitmap rotatedImage = new Bitmap(newWidth, newHeight, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
            rotatedImage.SetResolution(baseImage.HorizontalResolution, baseImage.VerticalResolution);

            // 3. Thực hiện xoay bằng Graphics
            using (Graphics g = Graphics.FromImage(rotatedImage))
            {
                // Đặt chất lượng cao
                g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;
                g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality;

                // Di chuyển gốc tọa độ về trung tâm ảnh mới
                g.TranslateTransform(newWidth / 2f, newHeight / 2f);

                // Xoay
                g.RotateTransform(angle);

                // Di chuyển gốc tọa độ về vị trí ảnh gốc
                g.TranslateTransform(-baseImage.Width / 2f, -baseImage.Height / 2f);

                // Vẽ ảnh gốc lên
                g.DrawImage(baseImage, 0, 0, baseImage.Width, baseImage.Height);
            }

            return rotatedImage;
        }

        private void btnAutoCropDropdown_Click(object sender, EventArgs e)
        {
            // Toggle trạng thái hiển thị của Panel
            pnlAutoCropMenu.Visible = !pnlAutoCropMenu.Visible;

            if (pnlAutoCropMenu.Visible)
            {
                // 1. Thiết lập vị trí của Panel (Panel nằm ngay dưới và căn lề trái với Button)
                pnlAutoCropMenu.Location = new Point(
                    btnAutoCropDropdown.Left,
                    btnAutoCropDropdown.Bottom
                );

                // 2. Đảm bảo Panel hiển thị trên tất cả các Control khác
                pnlAutoCropMenu.BringToFront();
            }
        }

        private void btnAutoCrop32_Click(object sender, EventArgs e)
        {
            // Tỷ lệ mong muốn: 3:2 (W:H)
            const float TARGET_RATIO = 3.0f / 2.0f; // Tức là 1.5

            if (workingImage == null)
            {
                MessageBox.Show("Không có ảnh để cắt. Vui lòng tải ảnh lên Form chính trước.", "Lỗi");
                return;
            }

            Bitmap currentImage = workingImage;
            int originalW = currentImage.Width;
            int originalH = currentImage.Height;
            float originalRatio = (float)originalW / originalH;

            Rectangle cropArea;

            // === LOGIC TÍNH TOÁN VÙNG CẮT 3:2 ===
            if (originalRatio > TARGET_RATIO) // Ảnh rộng hơn (W/H > 1.5) -> Cắt theo Chiều cao
            {
                // Giữ nguyên H, tính lại W sao cho W = H * 1.5
                int newW = (int)(originalH * TARGET_RATIO);
                int offsetX = (originalW - newW) / 2; // Căn giữa

                cropArea = new Rectangle(offsetX, 0, newW, originalH);
            }
            else // Ảnh cao hơn (W/H <= 1.5) -> Cắt theo Chiều rộng
            {
                // Giữ nguyên W, tính lại H sao cho H = W / 1.5
                int newH = (int)(originalW / TARGET_RATIO);
                int offsetY = (originalH - newH) / 2; // Căn giữa

                cropArea = new Rectangle(0, offsetY, originalW, newH);
            }

            // === 3. Thực hiện Crop và cập nhật trạng thái xem trước ===
            try
            {
                if (cropArea.Width > 0 && cropArea.Height > 0)
                {
                    // Cắt trên ảnh hiện tại (workingImage)
                    Bitmap croppedBitmap = currentImage.Clone(cropArea, currentImage.PixelFormat);

                    // QUAN TRỌNG: Giải phóng ảnh cũ và gán ảnh mới đã cắt vào workingImage
                    if (workingImage != null) workingImage.Dispose();
                    workingImage = croppedBitmap;

                    // Hiển thị ảnh mới để xem trước
                    pictureBoxCrop.Image = workingImage;

                    // Reset vùng chọn thủ công
                    selectionRect = Rectangle.Empty;
                    isSelecting = false;
                    pictureBoxCrop.Invalidate();

                    MessageBox.Show("Ảnh đã được cắt tự động 3:2. Vui lòng nhấn 'Áp dụng' để xác nhận.", "Thông Báo");
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Lỗi trong quá trình cắt tự động 3:2: {ex.Message}");
            }
        }

        private void btnAutoCrop169_Click(object sender, EventArgs e)
        {
            // Tỷ lệ mong muốn: 16:9 (W:H)
            const float TARGET_RATIO = 16.0f / 9.0f; // Khoảng 1.7778

            if (workingImage == null)
            {
                MessageBox.Show("Không có ảnh để cắt. Vui lòng tải ảnh lên Form chính trước.", "Lỗi");
                return;
            }

            Bitmap currentImage = workingImage;
            int originalW = currentImage.Width;
            int originalH = currentImage.Height;
            float originalRatio = (float)originalW / originalH;

            Rectangle cropArea;

            // === LOGIC TÍNH TOÁN VÙNG CẮT 16:9 ===
            if (originalRatio > TARGET_RATIO) // Ảnh rộng hơn (W/H > 16/9) -> Cắt theo Chiều cao
            {
                // Giữ nguyên H, tính lại W sao cho W = H * (16/9)
                int newW = (int)(originalH * TARGET_RATIO);
                int offsetX = (originalW - newW) / 2; // Căn giữa theo chiều ngang

                cropArea = new Rectangle(offsetX, 0, newW, originalH);
            }
            else // Ảnh cao hơn (W/H <= 16/9) -> Cắt theo Chiều rộng
            {
                // Giữ nguyên W, tính lại H sao cho H = W / (16/9)
                int newH = (int)(originalW / TARGET_RATIO);
                int offsetY = (originalH - newH) / 2; // Căn giữa theo chiều dọc

                cropArea = new Rectangle(0, offsetY, originalW, newH);
            }

            // === 3. Thực hiện Crop và cập nhật trạng thái xem trước ===
            try
            {
                if (cropArea.Width > 0 && cropArea.Height > 0)
                {
                    // Cắt trên ảnh hiện tại (workingImage)
                    Bitmap croppedBitmap = currentImage.Clone(cropArea, currentImage.PixelFormat);

                    // QUAN TRỌNG: Giải phóng ảnh cũ và gán ảnh mới đã cắt vào workingImage
                    if (workingImage != null) workingImage.Dispose();
                    workingImage = croppedBitmap;

                    // Hiển thị ảnh mới để xem trước
                    pictureBoxCrop.Image = workingImage;

                    // Reset vùng chọn thủ công
                    selectionRect = Rectangle.Empty;
                    isSelecting = false;
                    pictureBoxCrop.Invalidate();

                    MessageBox.Show("Ảnh đã được cắt tự động 16:9. Vui lòng nhấn 'Áp dụng' để xác nhận.", "Thông Báo");
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Lỗi trong quá trình cắt tự động 16:9: {ex.Message}");
            }
        }

        private void btnAutoCrop23_Click(object sender, EventArgs e)
        {
            // Tỷ lệ mong muốn: Chiều Ngang : Chiều Cao = 2:3 (Ví dụ: 4x6 cm)
            const float TARGET_RATIO = 2.0f / 3.0f; // Khoảng 0.6667

            if (workingImage == null)
            {
                MessageBox.Show("Không có ảnh để cắt. Vui lòng tải ảnh lên Form chính trước.", "Lỗi");
                return;
            }

            Bitmap currentImage = workingImage;
            int originalW = currentImage.Width;
            int originalH = currentImage.Height;
            float originalRatio = (float)originalW / originalH;

            Rectangle cropArea;

            // === LOGIC TÍNH TOÁN VÙNG CẮT 2:3 ===
            if (originalRatio > TARGET_RATIO) // Ảnh rộng hơn (W/H > 2/3) -> Cắt theo Chiều cao
            {
                // Giữ nguyên H, tính lại W sao cho W = H * (2/3)
                int newW = (int)(originalH * TARGET_RATIO);
                int offsetX = (originalW - newW) / 2; // Căn giữa theo chiều ngang

                cropArea = new Rectangle(offsetX, 0, newW, originalH);
            }
            else // Ảnh cao hơn (W/H <= 2/3) -> Cắt theo Chiều rộng
            {
                // Giữ nguyên W, tính lại H sao cho H = W / (2/3)
                int newH = (int)(originalW / TARGET_RATIO);
                int offsetY = (originalH - newH) / 2; // Căn giữa theo chiều dọc

                cropArea = new Rectangle(0, offsetY, originalW, newH);
            }

            // === 3. Thực hiện Crop và cập nhật trạng thái xem trước ===
            try
            {
                if (cropArea.Width > 0 && cropArea.Height > 0)
                {
                    // Cắt trên ảnh hiện tại (workingImage)
                    Bitmap croppedBitmap = currentImage.Clone(cropArea, currentImage.PixelFormat);

                    // QUAN TRỌNG: Giải phóng ảnh cũ và gán ảnh mới đã cắt vào workingImage
                    if (workingImage != null) workingImage.Dispose();
                    workingImage = croppedBitmap;

                    // Hiển thị ảnh mới để xem trước
                    pictureBoxCrop.Image = workingImage;

                    // Reset vùng chọn thủ công
                    selectionRect = Rectangle.Empty;
                    isSelecting = false;
                    pictureBoxCrop.Invalidate();

                    MessageBox.Show("Ảnh đã được cắt tự động theo tỷ lệ 2:3 (Passport). Vui lòng nhấn 'Áp dụng' để xác nhận.", "Thông Báo");
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Lỗi trong quá trình cắt tự động 2:3: {ex.Message}");
            }
        }

        private void btnAutoCrop31_Click(object sender, EventArgs e)
        {
            // Tỷ lệ mong muốn: Chiều Ngang : Chiều Cao = 3:1
            const float TARGET_RATIO = 3.0f / 1.0f; // Tức là 3.0

            if (workingImage == null)
            {
                MessageBox.Show("Không có ảnh để cắt. Vui lòng tải ảnh lên Form chính trước.", "Lỗi");
                return;
            }

            Bitmap currentImage = workingImage;
            int originalW = currentImage.Width;
            int originalH = currentImage.Height;
            float originalRatio = (float)originalW / originalH; // Tỷ lệ ảnh gốc (W/H)

            Rectangle cropArea;

            // === LOGIC TÍNH TOÁN VÙNG CẮT 3:1 ===
            if (originalRatio > TARGET_RATIO) // Ảnh rộng hơn 3:1 (W/H > 3.0) -> Cắt theo Chiều cao (giảm W)
            {
                // Giữ nguyên H, tính lại W sao cho W = H * 3.0
                int newW = (int)(originalH * TARGET_RATIO);
                int offsetX = (originalW - newW) / 2; // Căn giữa theo chiều ngang

                cropArea = new Rectangle(offsetX, 0, newW, originalH);
            }
            else // Ảnh cao hơn hoặc bằng 3:1 (W/H <= 3.0) -> Cắt theo Chiều rộng (giảm H)
            {
                // Giữ nguyên W, tính lại H sao cho H = W / 3.0
                int newH = (int)(originalW / TARGET_RATIO);
                int offsetY = (originalH - newH) / 2; // Căn giữa theo chiều dọc

                cropArea = new Rectangle(0, offsetY, originalW, newH);
            }

            // === 3. Thực hiện Crop và cập nhật trạng thái xem trước ===
            try
            {
                if (cropArea.Width > 0 && cropArea.Height > 0)
                {
                    // Cắt trên ảnh hiện tại (workingImage)
                    Bitmap croppedBitmap = currentImage.Clone(cropArea, currentImage.PixelFormat);

                    // QUAN TRỌNG: Giải phóng ảnh cũ và gán ảnh mới đã cắt vào workingImage
                    if (workingImage != null) workingImage.Dispose();
                    workingImage = croppedBitmap;

                    // Hiển thị ảnh mới để xem trước
                    pictureBoxCrop.Image = workingImage;

                    // Reset vùng chọn thủ công
                    selectionRect = Rectangle.Empty;
                    isSelecting = false;
                    pictureBoxCrop.Invalidate();

                    MessageBox.Show("Ảnh đã được cắt tự động theo tỷ lệ 3:1. Vui lòng nhấn 'Áp dụng' để xác nhận.", "Thông Báo");
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Lỗi trong quá trình cắt tự động 3:1: {ex.Message}");
            }
        }

        private void btnApplyCustomRatio_Click(object sender, EventArgs e)
        {
            if (workingImage == null)
            {
                MessageBox.Show("Không có ảnh để cắt. Vui lòng tải ảnh lên trước.", "Lỗi");
                return;
            }

            // 1. Đọc và Kiểm tra Input từ TextBox
            if (!int.TryParse(txtCustomWidth.Text, out int desiredW) || !int.TryParse(txtCustomHeight.Text, out int desiredH))
            {
                MessageBox.Show("Vui lòng nhập số hợp lệ cho Chiều Rộng và Chiều Cao.", "Lỗi Input");
                return;
            }

            if (desiredW <= 0 || desiredH <= 0)
            {
                MessageBox.Show("Chiều Rộng và Chiều Cao phải lớn hơn 0.", "Lỗi Input");
                return;
            }

            // 2. Thiết lập Tỷ lệ Mục tiêu
            float TARGET_RATIO = (float)desiredW / desiredH;

            Bitmap currentImage = workingImage;
            int originalW = currentImage.Width;
            int originalH = currentImage.Height;
            float originalRatio = (float)originalW / originalH;

            Rectangle cropArea;

            // 3. LOGIC CẮT ẢNH TÙY CHỈNH
            if (originalRatio > TARGET_RATIO) // Ảnh gốc rộng hơn tỷ lệ tùy chỉnh -> Cắt theo Chiều cao (giảm W)
            {
                // Giữ nguyên H, tính lại W sao cho W = H * TARGET_RATIO
                int newW = (int)(originalH * TARGET_RATIO);
                int offsetX = (originalW - newW) / 2; // Căn giữa

                cropArea = new Rectangle(offsetX, 0, newW, originalH);
            }
            else // Ảnh gốc cao hơn hoặc bằng tỷ lệ tùy chỉnh -> Cắt theo Chiều rộng (giảm H)
            {
                // Giữ nguyên W, tính lại H sao cho H = W / TARGET_RATIO
                int newH = (int)(originalW / TARGET_RATIO);
                int offsetY = (originalH - newH) / 2; // Căn giữa

                cropArea = new Rectangle(0, offsetY, originalW, newH);
            }

            // 4. Thực hiện Crop và cập nhật trạng thái
            try
            {
                if (cropArea.Width > 0 && cropArea.Height > 0)
                {
                    Bitmap croppedBitmap = currentImage.Clone(cropArea, currentImage.PixelFormat);

                    // Cập nhật workingImage và xem trước
                    if (workingImage != null) workingImage.Dispose();
                    workingImage = croppedBitmap;

                    pictureBoxCrop.Image = workingImage;

                    // Reset vùng chọn thủ công
                    selectionRect = Rectangle.Empty;
                    isSelecting = false;
                    pictureBoxCrop.Invalidate();

                    MessageBox.Show($"Ảnh đã được cắt tự động theo tỷ lệ {desiredW}:{desiredH}. Vui lòng nhấn 'Áp dụng' để xác nhận.", "Thông Báo");
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Lỗi trong quá trình cắt tự động: {ex.Message}");
            }
        }

        private void txtCustomWidth_KeyPress(object sender, KeyPressEventArgs e)
        {
            // Chỉ cho phép nhập số, Backspace, và dấu chấm thập phân (nếu cần cho số thập phân)
            // Nếu bạn chỉ muốn số nguyên, hãy bỏ kiểm tra dấu chấm ('.')
            if (!char.IsControl(e.KeyChar) && !char.IsDigit(e.KeyChar))
            {
                e.Handled = true;
            }
        }

        private void txtCustomHeight_KeyPress(object sender, KeyPressEventArgs e)
        {
            // Chỉ cho phép nhập số, Backspace, và dấu chấm thập phân (nếu cần cho số thập phân)
            // Nếu bạn chỉ muốn số nguyên, hãy bỏ kiểm tra dấu chấm ('.')
            if (!char.IsControl(e.KeyChar) && !char.IsDigit(e.KeyChar))
            {
                e.Handled = true;
            }
        }
    }
}
